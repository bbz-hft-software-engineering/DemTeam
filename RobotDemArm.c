#pragma config(Motor,  motorA,          AxisA,         tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          AxisB,         tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          AxisC,         tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          AxisD,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{

	//init
	char demText[] 		= 	"I AM NOT A ROBOT";

	int	demTextLength = 	sizeof(demText)- 1;

	float angleA, angleB, angleBC, angleC, angleD, result1, result2, result3, result4, result5, result6, cc, ck, cx, cy, cz, angleBCnow;
	int plusMinusSpeedA, plusMinusSpeedBC, plusMinusSpeedD, velocity, charPointer;

	int setstart = 0;

	//init Konstanten

	float ca = 125, cb = 120, ch = 153;
	float ox = 1.05, oz = 7, oy = 5;

	while(true)
	{
		//start or restart button low speed
		if(getButtonPress(buttonRight) == 1)
		{
			setstart = 1;
			charPointer = 0;

			velocity 	=	 10;

			plusMinusSpeedA 	=		velocity;
			plusMinusSpeedBC 	= 	velocity;
			plusMinusSpeedD 	= 	velocity;
		}
		//start or restart button high speed
		if(getButtonPress(buttonLeft) == 1)
		{
			setstart = 1;
			charPointer = 0;

			velocity 	=	 18;

			plusMinusSpeedA 	=		velocity;
			plusMinusSpeedBC 	= 	velocity;
			plusMinusSpeedD 	= 	velocity;
		}

		while(setstart == 1)
		{


//init temp zero Pos
			setMotorBrakeMode(AxisA,motorBrake);
			setMotorBrakeMode(AxisB,motorBrake);
			setMotorBrakeMode(AxisC,motorBrake);
			setMotorBrakeMode(AxisD,motorBrake);
			resetMotorEncoder(AxisA);
			resetMotorEncoder(AxisB);
			resetMotorEncoder(AxisC);
			resetMotorEncoder(AxisD);

			//move Axis D to save position
			setMotorTarget(motorD, -55, 5);
			waitUntilMotorStop(motorD);

			setMotorBrakeMode(AxisD,motorBrake);

//move Axis A and BC to zero position
			setMotorTarget(motorA, 95, 5);
			waitUntilMotorStop(motorA);

			setMotorBrakeMode(AxisA,motorBrake);

			setMotorSyncEncoder(motorB, motorC, 0, 6, -5);
			waitUntilMotorStop(motorB);
			waitUntilMotorStop(motorC);

			setMotorBrakeMode(AxisB,motorBrake);
			setMotorBrakeMode(AxisC,motorBrake);
			delay(300);

			//Set zero Axis A and BC
			resetMotorEncoder(AxisB);
			resetMotorEncoder(AxisC);

			//move Axis BC to wait position
			setMotorSyncEncoder(motorB, motorC, 0, 120, -5);

//move Axis D to zero position
			setMotorTarget(motorD, 71, 5);

			waitUntilMotorStop(motorB);
			waitUntilMotorStop(motorC);
			waitUntilMotorStop(motorD);

			setMotorBrakeMode(AxisB,motorBrake);
			setMotorBrakeMode(AxisC,motorBrake);
			setMotorBrakeMode(AxisD,motorBrake);
			delay(150);

			//set zero Axis D
			resetMotorEncoder(AxisD);

			//move Axis D to wait position
			setMotorTarget(motorD, 90, 10);
			waitUntilMotorStop(motorD);

			setMotorBrakeMode(AxisD,motorBrake);

//Button coordinates
			for(int i =0 ; i < demTextLength; i++){
				if(demText[charPointer] == 'Q')
				{
					cx = 213;
					cy = -135;
					cz = 30;
				}
				if(demText[charPointer] == 'W')
				{
					cx = 213;
					cy = -106;
					cz = 30;
				}
				if(demText[charPointer] == 'E')
				{
					cx = 213;
					cy = -77;
					cz = 30;
				}
				if(demText[charPointer] == 'R')
				{
					cx = 213;
					cy = -48;
					cz = 30;
				}
				if(demText[charPointer] == 'T')
				{
					cx = 215;
					cy = -23;
					cz = 30;
				}
				if(demText[charPointer] == 'Z')
				{
					cx = 213;
					cy = 10;
					cz = 30;
				}
				if(demText[charPointer] == 'U')
				{
					cx = 213;
					cy = 39;
					cz = 30;
				}
				if(demText[charPointer] == 'I')
				{
					cx = 213;
					cy = 75;
					cz = 35;
				}
				if(demText[charPointer] == 'O')
				{
					cx = 213;
					cy = 97;
					cz = 30;
				}
				if(demText[charPointer] == 'P')
				{
					cx = 213;
					cy = 126;
					cz = 30;
				}
				if(demText[charPointer] == 'A')
				{
					cx = 188;
					cy = -93;
					cz = 30;
				}
				if(demText[charPointer] == 'S')
				{
					cx = 188;
					cy = -77;
					cz = 30;
				}
				if(demText[charPointer] == 'D')
				{
					cx = 188;
					cy = -48;
					cz = 30;
				}
				if(demText[charPointer] == 'F')
				{
					cx = 188;
					cy = -19;
					cz = 30;
				}
				if(demText[charPointer] == 'G')
				{
					cx = 188;
					cy = 10;
					cz = 30;
				}
				if(demText[charPointer] == 'H')
				{
					cx = 188;
					cy = 39;
					cz = 30;
				}
				if(demText[charPointer] == 'J')
				{
					cx = 188;
					cy = 68;
					cz = 30;
				}
				if(demText[charPointer] == 'K')
				{
					cx = 188;
					cy = 97;
					cz = 30;
				}
				if(demText[charPointer] == 'L')
				{
					cx = 188;
					cy = 126;
					cz = 30;
				}
				if(demText[charPointer] == 'Y')
				{
					cx = 150;
					cy = -106;
					cz = 32;
				}
				if(demText[charPointer] == 'X')
				{
					cx = 150;
					cy = -77;
					cz = 32;
				}
				if(demText[charPointer] == 'C')
				{
					cx = 150;
					cy = -48;
					cz = 32;
				}
				if(demText[charPointer] == 'V')
				{
					cx = 150;
					cy = -19;
					cz = 32;
				}
				if(demText[charPointer] == 'B')
				{
					cx = 150;
					cy = 5;
					cz = 32;
				}
				if(demText[charPointer] == 'N')
				{
					cx = 150;
					cy = 40;
					cz = 32;
				}
				if(demText[charPointer] == 'M')
				{
					cx = 150;
					cy = 64;
					cz = 32;
				}
				if(demText[charPointer] == ' ')
				{
					cx = 128;
					cy = 5;
					cz = 36;
				}

//calculations

				//calc angle Axis A
				angleA = atan((cy-(-oy)) / cx) * 180/PI;

				//invert direction Axis A
				angleA = (angleA*(-1.25)+94);

				//calc angle Axis BC
				ck = sqrt(pow((cx*ox),2) + pow((cy-(-oy)),2)) - 70;
				cc = sqrt(pow(ch-cz+(-oz), 2) + pow(ck,2));

				// Calc angle B
				result1 = (cc*cc + (ch-cz) * (ch-cz) - ck*ck) / (2 * cc *(ch-cz));
				result2 = acos(result1);
				angleB = result2 * 180/PI;

				// Calc angle C
				result3 = (cb*cb + cc*cc - ca*ca) / (2 * cb * cc);
				result4 = acos(result3);
				angleC = result4 * 180/PI;
				angleBC = angleB + angleC;

				//move direction Axis BC
				if(-getMotorEncoder(motorB)> angleBC && plusMinusSpeedBC < 0)
				{
					plusMinusSpeedBC = plusMinusSpeedBC*(-1);
				}
				if(-getMotorEncoder(motorB)< angleBC && plusMinusSpeedBC > 0)
				{
					plusMinusSpeedBC = plusMinusSpeedBC*(-1);
				}

				//angle absolut to incremental
				angleBCnow = getMotorEncoder(motorB)*(-1);
				angleBC = angleBC - angleBCnow;

				//calc angle Axis D
				result5 = (ca*ca + cb*cb - cc*cc) / (2 * ca * cb);
				result6 = acos(result5);
				angleD = 180-(result6 * 180/PI);
				angleD = angleD*(-1);

//Move Axis

				//move Axis A und D
				setMotorTarget(motorA, angleA, plusMinusSpeedA);
				setMotorTarget(motorD, -angleD, plusMinusSpeedD);

				waitUntilMotorStop(motorA);
				waitUntilMotorStop(motorD);

				setMotorBrakeMode(AxisA,motorBrake);
				setMotorBrakeMode(AxisD,motorBrake);

				//move Axis BC
				setMotorSyncEncoder(motorB, motorC, 0, angleBC, plusMinusSpeedBC);

				waitUntilMotorStop(motorB);
				waitUntilMotorStop(motorC);

				setMotorBrakeMode(AxisB,motorBrake);
				setMotorBrakeMode(AxisC,motorBrake);

				//move Axis BC back to wait pos
				angleBC = 105;

				//move direction Axis BC
				if(-getMotorEncoder(motorB)> angleBC && plusMinusSpeedBC < 0)
				{
					plusMinusSpeedBC = plusMinusSpeedBC*(-1);
				}
				if(-getMotorEncoder(motorB)< angleBC && plusMinusSpeedBC > 0)
				{
					plusMinusSpeedBC = plusMinusSpeedBC*(-1);
				}

				//angle absolut to incremental
				angleBCnow = getMotorEncoder(motorB)*(-1);
				angleBC = angleBC - angleBCnow;

				setMotorSyncEncoder(motorB, motorC, 0, angleBC, plusMinusSpeedBC);

				waitUntilMotorStop(motorB);
				waitUntilMotorStop(motorC);

				setMotorBrakeMode(AxisB,motorBrake);
				setMotorBrakeMode(AxisC,motorBrake);

//go to next button
				charPointer = charPointer + 1;
				setstart = 0;
			}

//finished. go to calibration pos

			//calc move Axis BC back to calibration pos
			angleBC = -7;

			//move direction Axis BC
			if(-getMotorEncoder(motorB)> angleBC && plusMinusSpeedBC < 0)
			{
				plusMinusSpeedBC = plusMinusSpeedBC*(-1);
			}
			if(-getMotorEncoder(motorB)< angleBC && plusMinusSpeedBC > 0)
			{
				plusMinusSpeedBC = plusMinusSpeedBC*(-1);
			}

			//angle absolut to incremental
			angleBCnow = getMotorEncoder(motorB)*(-1);
			angleBC = angleBC - angleBCnow;

			//move Axis A BC und D to calibration pos
			setMotorTarget(motorD, -130, 30);
			delay(150);
			setMotorSyncEncoder(motorB, motorC, 0, angleBC, 15);
			setMotorTarget(motorA, -9, 5);

			waitUntilMotorStop(motorB);
			waitUntilMotorStop(motorC);
			waitUntilMotorStop(motorD);
			waitUntilMotorStop(motorA);

			setMotorBrakeMode(motorA, motorCoast);

			setMotorTarget(motorD, -72, 20);

			waitUntilMotorStop(motorD);

			setMotorBrakeMode(motorB, motorCoast);
			setMotorBrakeMode(motorC, motorCoast);
			setMotorBrakeMode(motorD, motorCoast);
		}
	}
}
